缓存击穿问题（热点Key问题）
当一个被高并发访问且缓存重建业务交复杂的Key突然失效，大量的请求访问会在瞬间冲击数据库。

**常见的解决方案：**
- 互斥锁
- 逻辑过期

**逻辑分析：** 
- 线程1在缓存未命中后开始查询数据库并准备将数据回填至缓存。在此过程中，若线程1尚未完成，线程2、3、4等相继访问同一方法。由于数据尚未被线程1加载进缓存，这些线程均无法从缓存获取，导致它们**同步转向数据库查询**。这种并发场景下，多个线程**同时访问数据库**，造成数据库访问压力显著增大。

1. **互斥锁：**
	为防止多线程并发访问导致数据库压力过大，可引入锁实现互斥访问，确保同一时刻仅一个线程访问数据库。但这会将原本并行的查询变为串行，影响性能。我们采用`tryLock`结合双检查（double check）策略：

	- 线程1查询缓存未命中，成功获取锁，独占执行数据库查询+缓存回填的逻辑。
	- 后续线程（如线程2）在尝试获取锁失败时，进入等待状态。
	-  线程1完成操作后释放锁，唤醒等待的线程2。
	-  线程2再次尝试获取锁（double check），发现缓存命中，从已填充数据的缓存中直接取数据，无需再访问数据库。

2. **逻辑过期：**
	出现缓存击穿问题主要归因于对key设定了过期时间。为避免此问题又不长期占用内存，我们采用**逻辑过期方案**。

	**存储逻辑过期时间：** 在Redis value中存放数据的过期时间，但不直接让Redis据此自动过期，而是由应用逻辑处理过期判断。
    - 线程1查询缓存，发现value中记录的数据已过期。
    - 线程1获取互斥锁，阻止其他线程同时访问。
    - 线程1启动新线程负责重构过期数据，自身则立即返回旧数据。

	**并发访问处理：** 
    - 线程3在数据重建期间访问时，因锁被线程2持有，故无法获取，直接返回现有（可能已过期的）缓存数据。
    - 待新线程完成数据重构并更新缓存后，释放锁。
    - 此后访问的线程得以获取更新后的正确数据。

	**优点**：异步重建缓存，不影响主线程响应速度。
	**缺点**：在数据重建完成前，部分请求可能返回过期（脏）数据。

| 解决方案 |             优点             | 缺点                              |
| :--: | :------------------------: | :-----------------------------: |
| 互斥锁  | 没有额外的内存消耗<br>保证一致性<br>实现简单 | - 线程需要等待，性能受影响<br>- 可能有死锁风险     |
| 逻辑过期 |       - 线程无需等待，性能较好        | - 不保证一致性<br>- 有额外内存消耗<br>- 实现复杂 |

