<h2 style="" id="%E4%B8%80%E3%80%81%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98"><span fontsize="" color="rgb(17, 24, 39)" style="color: rgb(17, 24, 39)">一、</span><strong><span fontsize="" color="rgb(17, 24, 39)" style="color: rgb(17, 24, 39)">缓存穿透问题</span></strong></h2><div class="markdown-edited"><p>缓存穿透是指客户端请求的数据在缓存和数据库中都不存在，这样缓存永远不会生效，而且所有的请求都会经过数据库。</p>
<p><strong>常见的解决方案有</strong>：</p>
<ul>
<li>缓存空对象：<ul>
<li>优点：实现简单，维护方便</li>
<li>缺点：<ul>
<li>额外的内存消耗</li>
<li>可能造成短期的不一致</li>
</ul>
</li>
</ul>
</li>
<li>布隆过滤：<ul>
<li>优点：内存占用较少，没有多余key</li>
<li>缺点：<ul>
<li>实现复杂</li>
<li>存在误判可能</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li><p><strong>缓存空对象</strong>：</p>
<ul>
<li>客户端访问不存在的数据，先请求Redis，Redis中没有此数据，接着访问数据库，数据库也没有此数据。这个数据穿透了缓存，直击数据库。（由于数据库能够承载的并发不如Redis，若大量请求访问数据库，则可能导致数据库瘫痪）</li>
<li>解决方案：<ul>
<li>当请求数据库不存在的数据时，就把不存在的数据缓存到Redis中，并设置一个短期<strong>TTL</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>布隆过滤器</strong>：</p>
<ul>
<li>其采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，用哈希思想去判断当前要查询数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问Redis，尽管此时Redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到Redis中。假设布隆过滤器判断这个数据不存在，则直接返回。</li>
<li>优点：节约内存空间</li>
<li>缺点：存在误判<ul>
<li>误判原因在于布隆过滤器采用了<strong>哈希思想</strong>，而基于哈希思想的机制，<strong>哈希冲突</strong>是其固有风险。</li>
</ul>
</li>
</ul>
</li>
</ol>
</div><p style=""><span fontsize="" color="rgb(17, 24, 39)" style="color: rgb(17, 24, 39)">  <img src="https://image.kangyaocoding.top/blog/post/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F-vedmxgzu.jpg" width="100%" height="100%" style="display: inline-block"></span></p><h2 style="" id="%E4%BA%8C%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98"><span fontsize="" color="rgb(17, 24, 39)" style="color: rgb(17, 24, 39)">二、</span><strong><span fontsize="" color="rgb(17, 24, 39)" style="color: rgb(17, 24, 39)">缓存雪崩问题</span></strong></h2><div class="markdown-edited"><p>缓存雪崩是指在同一时段，大量的缓存Key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p>
<p>解决方案：</p>
<ul>
<li>给不同的Key的TTL添加随机值。</li>
<li>利用Redis集群提高服务的可用性。</li>
<li>给缓存业务添加降级限流策略。</li>
<li>给业务添加多级缓存。</li>
</ul>
</div><p style="text-align: center; "><span fontsize="" color="rgb(17, 24, 39)" style="color: rgb(17, 24, 39)"><img src="https://image.kangyaocoding.top/blog/post/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9-zefuskdd.png" alt="缓存雪崩-zefuskdd.png" width="100%" height="100%" style="display: inline-block"></span></p><h2 style="" id="%E4%B8%89%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E9%97%AE%E9%A2%98"><span fontsize="" color="rgb(17, 24, 39)" style="color: rgb(17, 24, 39)">三、</span><strong><span fontsize="" color="rgb(17, 24, 39)" style="color: rgb(17, 24, 39)">缓存击穿问题</span></strong></h2><div class="markdown-edited"><p>缓存击穿问题（热点Key问题） 当一个被高并发访问且缓存重建业务交复杂的Key突然失效，大量的请求访问会在瞬间冲击数据库。</p>
<p><strong>常见的解决方案：</strong></p>
<ul>
<li>互斥锁</li>
<li>逻辑过期</li>
</ul>
<p><strong>逻辑分析：</strong></p>
<ul>
<li>线程1在缓存未命中后开始查询数据库并准备将数据回填至缓存。在此过程中，若线程1尚未完成，线程2、3、4等相继访问同一方法。由于数据尚未被线程1加载进缓存，这些线程均无法从缓存获取，导致它们<strong>同步转向数据库查询</strong>。这种并发场景下，多个线程<strong>同时访问数据库</strong>，造成数据库访问压力显著增大。</li>
</ul>
<ol>
<li><p><strong>互斥锁：</strong> 为防止多线程并发访问导致数据库压力过大，可引入锁实现互斥访问，确保同一时刻仅一个线程访问数据库。但这会将原本并行的查询变为串行，影响性能。我们采用<code>tryLock</code>结合双检查（double check）策略：</p>
<ul>
<li>线程1查询缓存未命中，成功获取锁，独占执行数据库查询+缓存回填的逻辑。</li>
<li>后续线程（如线程2）在尝试获取锁失败时，进入等待状态。</li>
<li>线程1完成操作后释放锁，唤醒等待的线程2。</li>
<li>线程2再次尝试获取锁（double check），发现缓存命中，从已填充数据的缓存中直接取数据，无需再访问数据库。</li>
</ul>
</li>
</ol>
</div><pre><code class="language-java">private boolean tryLock(String key) {
    Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, "1", 10, TimeUnit.SECONDS);
    return BooleanUtil.isTrue(flag);
}

private void unlock(String key) {
    stringRedisTemplate.delete(key);
}</code></pre><p style=""><span fontsize="" color="rgb(17, 24, 39)" style="color: rgb(17, 24, 39)"><img src="https://image.kangyaocoding.top/blog/post/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF-%E4%BA%92%E6%96%A5%E9%94%81-txtfszdg.png" width="100%" height="100%" style="display: inline-block"></span></p><div class="markdown-edited"><ol start="2">
<li><p><strong>逻辑过期：</strong> 出现缓存击穿问题主要归因于对key设定了过期时间。为避免此问题又不长期占用内存，我们采用<strong>逻辑过期方案</strong>。</p>
<p><strong>存储逻辑过期时间：</strong> 在Redis value中存放数据的过期时间，但不直接让Redis据此自动过期，而是由应用逻辑处理过期判断。</p>
<ul>
<li>线程1查询缓存，发现value中记录的数据已过期。</li>
<li>线程1获取互斥锁，阻止其他线程同时访问。</li>
<li>线程1启动新线程负责重构过期数据，自身则立即返回旧数据。</li>
</ul>
<p><strong>并发访问处理：</strong></p>
<ul>
<li>线程3在数据重建期间访问时，因锁被线程2持有，故无法获取，直接返回现有（可能已过期的）缓存数据。</li>
<li>待新线程完成数据重构并更新缓存后，释放锁。</li>
<li>此后访问的线程得以获取更新后的正确数据。</li>
</ul>
<p><strong>优点</strong>：异步重建缓存，不影响主线程响应速度。<br><strong>缺点</strong>：在数据重建完成前，部分请求可能返回过期（脏）数据。</p>
</li>
</ol>
</div><p style=""><span fontsize="" color="rgb(17, 24, 39)" style="color: rgb(17, 24, 39)"><img src="https://image.kangyaocoding.top/blog/post/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF-%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F-sckwcpuf.png" width="100%" height="100%" style="display: inline-block"></span></p><div class="html-edited"><table> <tbody><tr style="text-align: center;"> <th>解决方案</th> <th>优点</th> <th>缺点</th> </tr> <tr style="text-align: left;"> <td style="text-align: center;">互斥锁</td> <td>- 没有额外的内存消耗<br>- 保证一致性<br>- 实现简单</td> <td>- 线程需要等待，性能受影响<br>- 可能有死锁风险</td> </tr> <tr style="text-align: left;"> <td style="text-align: center;">逻辑过期</td> <td>- 线程无需等待，性能较好</td> <td>- 不保证一致性<br>- 有额外内存消耗<br>- 实现复杂</td> </tr> </tbody></table></div><blockquote><p style="text-align: center; "><strong><span fontsize="" color="rgb(17, 24, 39)" style="color: rgb(17, 24, 39)">图片和知识来源(结合自己的理解进行简化了许多)：</span></strong></p></blockquote><p style=""><iframe src="https://player.bilibili.com/player.html?aid=766995956&amp;bvid=BV1cr4y1671t&amp;cid=1428719496&amp;p=1&amp;autoplay=0" width="100%" height="400px" frameborder="0" allowfullscreen="true" framespacing="0" style="display: inline-block"></iframe></p><p style=""></p><p style=""></p><p style=""></p><p style=""></p><p style=""></p><p style=""></p><p style=""></p><p style=""></p>