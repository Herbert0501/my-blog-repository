
> 第二部分。

**简介** ：在 Java 中，多线程与并发编程是提升程序性能的关键领域。本篇文章将带你深入探索 Java 内存模型（JMM）。同时，深入线程池的七个核心参数，详细解读其工作过程，并为你介绍 Java 提供的四种经典线程池，让你学会如何根据实际需求选择合适的线程池。此外，还将分享线程池核心参数设置的实用技巧，助你优化线程池性能。而 synchronized、AQS 以及 volatile 这些并发编程中的重要概念，也将在本篇中得到深入解读。

### 1. JMM 是什么？

- **定义：** Java内存模型（JMM）规定了多线程环境下共享变量的访问规则，确保线程间的可见性、有序性和原子性。
    
- **核心机制：**
    
    - 使用主内存和工作内存的交互规则，结合 **happens - before** 原则保证操作顺序。
        
- **三大特性：**
    
    - **可见性：** 一个线程修改共享变量后，其他线程能立即感知。
        
    - **有序性：** 禁止指令重排序优化（通过内存屏障实现）。
        
    - **原子性：** JMM 不直接保证，需借助锁（如 `synchronized`）或原子类（如 `AtomicInteger`）实现。
        

### 2. 线程池的七个参数和工作过程

#### **七个参数**

- **corePoolSize：** 核心线程数（即使空闲也不会被回收）。
    
- **maximumPoolSize：** 最大线程数（包含核心线程）。
    
- **keepAliveTime：** 非核心线程空闲时的存活时间。
    
- **unit：** 存活时间单位（如 `TimeUnit.SECONDS`）。
    
- **workQueue：** 任务队列（如 `LinkedBlockingQueue`）。
    
- **threadFactory：** 线程工厂（自定义线程创建逻辑）。
    
- **handler：** 拒绝策略（如 `AbortPolicy` 直接抛异常）。
    

#### **工作过程**

1. 提交任务时，优先使用核心线程处理。
    
2. 核心线程已满时，任务进入工作队列。
    
3. 队列满时，创建非核心线程处理任务（直到达到 `maximumPoolSize`）。
    
4. 线程数和队列均满时，触发拒绝策略。
    

#### **四种内置线程池**

- **FixedThreadPool：** 固定核心线程，无界队列，潜在问题为队列堆积导致 OOM。
    
- **CachedThreadPool：** 无核心线程，最大线程数为 `Integer.MAX_VALUE`，问题为线程数可能失控。
    
- **SingleThreadExecutor：** 单线程，无界队列，问题为队列容易堆积。
    
- **ScheduledThreadPool：** 支持定时 / 周期性任务，需手动控制资源。
    

### 3. 线程池核心参数设置的技巧

- **任务类型：**
    
    - **CPU 密集型：** 核心线程数 ≈ CPU 核心数（+1 防止线程阻塞）。
        
    - **IO 密集型：** 核心线程数 ≈ 2 * CPU 核心数（充分利用等待时间）。
        
- **队列选择：**
    
    - 短任务 / 快速响应：使用 `SynchronousQueue`（直接传递任务，避免堆积）。
        
    - 长任务 / 缓冲：使用 `LinkedBlockingQueue`（需设合理容量防 OOM）。
        
- **拒绝策略：**
    
    - 自定义策略（如记录日志、降级处理）。
        
    - 避免直接丢弃（如 `DiscardPolicy`）导致数据丢失。
        
- **动态调整：** 可通过 `setCorePoolSize()` 等方法动态适应负载。
    

### 4. synchronized、AQS、volatile

#### **原理与应用场景**

- **synchronized：**
    
    - **原理：** 基于 JVM 的 `monitor` 锁，通过字节码指令 `monitorenter` / `monitorexit` 实现。
        
    - **应用：** 代码块或方法同步。
        
    - **特点：** 自动释放锁，支持可重入。
        
- **AQS（AbstractQueuedSynchronizer）：**
    
    - **原理：** 基于 `volatile` 变量 `state` 和 CLH 队列实现锁的获取与释放。
        
    - **应用：** 构建 `ReentrantLock`、`Semaphore` 等。
        
    - **特点：** 支持公平 / 非公平锁、可中断、超时等待。
        
- **volatile：**
    
    - **原理：** 通过内存屏障禁止指令重排，强制读写直接操作主内存。
        
    - **应用：** 状态标记（如 `boolean flag`）。
        
    - **特点：** 保证可见性和有序性，但不保证原子性。
        

#### **对比**

- **synchronized vs AQS：** `synchronized` 是 JVM 内置锁，无需手动释放；AQS 是 JDK 级实现，更灵活（如可中断、公平性）。
    
- **volatile 适用场景：** 单例模式双重检查锁、状态标记（如循环退出标志）。

### 5. 结尾

本篇文章带你探索了 Java 并发编程的多个关键领域，从线程内存模型到线程池的高效管理，再到同步机制的底层原理，相信你对 Java 多线程的世界有了更全面的认识。而下一篇，精彩将继续升级！我们将深入剖析 ConcurrentHashMap 的神奇原理，它如何在高并发场景下实现高效的数据存储与访问？当它在扩容时遭遇元素插入，又会如何巧妙应对？同时，HashMap 与 ConcurrentHashMap 的区别也将一目了然。不仅如此，IOC 和 AOP 这两大核心思想的原理也将详细呈现，它们是如何在 Java 世界中发挥着关键作用，提升代码的灵活性与可维护性。敬请期待，与 DeepSeek 一同开启更深入的 Java 技术探索之旅！