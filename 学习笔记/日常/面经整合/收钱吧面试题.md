## 一面1


3.买一张票从某地到某地，然后没有付钱，那订单系统是个什么状态？  
4.系统里面分布式锁是怎么做的？  
5.你提到了redlock，那它机制是怎么样的？
6.红锁能不能保证百分百上锁？  
7.Redis解决单点故障主要靠什么？  
8.红锁用了哪几种模式？那解决红锁问题Redis用哪种模式？  
9.主从模式用的是异步还是同步？  
11.RocketMQ的顺序消息？  
12.JVM的内存模型？  
13.你提到了栈帧，那局部变量表除了栈帧还有什么？  
14.一个什么都没有的空方法，完全空的参数什么都没有，那局部变量表里有没有变量？  
15.所有对象都在堆上对不对？
16.垃圾回收的过程？  
17.CMS用了什么垃圾回收算法？  
18.你提到了remark，那它remark具体是怎么执行的？三色标记法？  
19.ID是自增的，1000到10000，怎么从表中查ID=5000的数据？
  
作者：哈球池扶手包包  
链接：[https://www.nowcoder.com/feed/main/detail/0a57de19e92d4b99b6847c706dee4315?sourceSSR=search](https://www.nowcoder.com/feed/main/detail/0a57de19e92d4b99b6847c706dee4315?sourceSSR=search)  
来源：牛客网

## 二面1

3.Rocketmq在项目里怎么用的？  
4.Rocketmq延时消息的实现原理？
5.项目里订单号怎么设计的？
6.设计一个11位的订单号，保证它是全局唯一的，还要保证高并发，用什么算法？
7.高可用什么意思？  
8.高并发什么意思？  
  
作者：哈球池扶手包包  
链接：[https://www.nowcoder.com/feed/main/detail/0a57de19e92d4b99b6847c706dee4315?sourceSSR=search](https://www.nowcoder.com/feed/main/detail/0a57de19e92d4b99b6847c706dee4315?sourceSSR=search)  
来源：牛客网

## 一面2

1.什么叫线程安全  
2.Java里面有哪些基本类型，对应的包装类有哪些  
3.什么场景下使用包装类  
4.包装类线程安全吗？                                                
5.String安全吗？为啥使用final就安全了  
6.说一下Java的类加载器，引出了双亲委派  
7.为什么要有双亲委派机制，目的是什么  
8.redis的数据结构 应用场景   
9.类加载机制  
  
作者：坚定的小猫在秋招  
链接：[https://www.nowcoder.com/feed/main/detail/db104a17b7ee408c868e24b7b69021eb?sourceSSR=search](https://www.nowcoder.com/feed/main/detail/db104a17b7ee408c868e24b7b69021eb?sourceSSR=search)  
来源：牛客网

## 笔试1

### ① 缓存与数据库的一致性问题、改进与常见的缓存更新模式

**缓存与数据库一致性问题**主要在于，缓存和数据库之间的数据可能不同步，从而引发数据不一致的问题。数据一致性问题有以下几种类型：

- **强一致性**：每次数据的读取操作都能确保读到最新的更新数据。强一致性往往带来较大的性能开销。
- **最终一致性**：允许一段时间内数据可能不一致，但最终会达到一致。许多分布式系统追求这种一致性。
- **弱一致性**：数据在大多数情况下是一致的，但不保证每次读取都能获取到最新的数据。

**缓存更新模式的常见改进方式：**

1. **Cache Aside (旁路缓存模式)**
   - **工作流程**：应用程序先从缓存读取数据，若缓存中不存在，则从数据库中读取并回填到缓存中。
   - **优点**：缓存只存放热点数据，降低了缓存压力。
   - **缺点**：可能会导致缓存与数据库的不一致性，尤其是数据更新时。

2. **Write Through (直写缓存模式)**
   - **工作流程**：每当数据更新时，首先更新缓存，然后再同步更新数据库。
   - **优点**：确保缓存和数据库的数据同步。
   - **缺点**：写操作的延迟增加，因为必须同步到数据库。

3. **Write Back (回写缓存模式)**
   - **工作流程**：数据更新时，先更新缓存，数据库的更新则是异步进行的，只有在缓存替换时才会写回数据库。
   - **优点**：提高写操作的性能。
   - **缺点**：数据持久性问题，如果缓存数据丢失，可能导致数据丢失。

4. **Cache Invalidation (缓存失效)**
   - **工作流程**：当数据库中的数据更新时，缓存数据立即失效，等待下一次访问时再加载最新数据。
   - **优点**：缓存数据及时更新，确保一致性。
   - **缺点**：缓存失效可能引起缓存穿透或缓存雪崩问题。

**改进建议**：
- 通过引入**事务性缓存更新机制**，保证缓存与数据库的同步。
- 使用**TTL（Time to Live）机制**，设置缓存的过期时间以避免长期不一致。
- 在高并发场景下引入**分布式锁机制**，确保缓存与数据库的更新顺序。

### ② Prometheus的两种模式对比、pull模式的高基数问题和无界数据流处理

#### Prometheus的两种模式对比

Prometheus主要有两种数据采集模式：**Pull（拉取模式）** 和 **Push（推送模式）**。

1. **Pull模式**：
   - **工作流程**：Prometheus定期从各个监控目标（targets）拉取指标数据。
   - **优点**：简单、易于管理和扩展。适用于大部分场景，并且Prometheus可以动态地发现目标。
   - **缺点**：对于需要实时推送的指标，Pull模式可能不适用；另外，高基数的监控数据可能导致性能问题，因为需要维护大量的监控目标。

2. **Push模式**：
   - **工作流程**：通过Prometheus PushGateway，目标将数据主动推送给Prometheus。
   - **优点**：适用于短生命周期的作业或临时指标数据。
   - **缺点**：需要额外的PushGateway组件，复杂度有所增加；而且缺乏自动发现机制。

#### Pull模式的高基数问题

**高基数问题**是指监控目标（metrics）中标签（label）组合的数量过多，导致Prometheus在存储和查询上出现性能瓶颈。高基数数据会导致：
- 内存占用过大。
- 查询效率降低。

**解决高基数问题的建议**：
- **限制标签数量和标签值的取值范围**，避免无谓的维度增加。
- 使用适当的指标聚合方式，减少需要存储的原始数据量。
- 使用**Recording Rules**提前聚合指标，减少查询时的资源消耗。

#### 无界数据流中如何判断某个数是否出现过及其出现次数

无界数据流是指数据源是无界限的，流数据会不断产生，通常在分布式系统中很难进行传统的全量计算。这类问题的解决通常使用如下几种方法：

1. **Bloom Filter（布隆过滤器）**：
   - **工作原理**：布隆过滤器是一种基于哈希的概率性数据结构，可以判断一个元素是否存在于集合中。其优点是空间复杂度低，但存在一定的误判率，即可能会说某个数存在但实际上不存在。
   - **适用场景**：快速判断某个数是否出现过，特别适合内存敏感的场景。

2. **HyperLogLog**：
   - **工作原理**：一种近似算法，常用于估算不重复元素的基数（即唯一值的个数）。它能在小的空间内保持较高的估计精度。
   - **适用场景**：在需要估算大规模不重复元素的数量时使用。

3. **Count-Min Sketch**：
   - **工作原理**：类似于布隆过滤器，是一种概率数据结构，可以用于估算元素出现的频率。它的空间效率较高，允许一定的误差。
   - **适用场景**：在流式数据中，快速统计某个元素的出现次数。

4. **Sliding Window（滑动窗口）**：
   - **工作原理**：在无界数据流的处理过程中，通过限定一个时间窗口内的数据量（比如最后5分钟内的数据），可以近似地统计出数据的出现情况。
   - **适用场景**：对于时间敏感的场景，滑动窗口是一种常用的技术，可以避免无穷增长的数据量。

通过结合这些方法，可以在无界数据流中高效地判断某个数是否出现过，并且估算其出现次数。