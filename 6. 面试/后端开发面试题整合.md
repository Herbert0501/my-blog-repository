
## Java 知识

### 什么是线程，如何创建？

**描述**： 

1. 线程是操作系统能够进行运算调度的基本单位，是 Java 的基本执行单元。
2. 线程在独立的程序计数器、栈和局部变量空间运行。
3. 共享堆内存中的资源。

**创建**：
1. 继承`Thread`类。
```Java
class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("Thread is running");
    }
}

public class Main {
    public static void main(String[] args) {
        MyThread thread = new MyThread();
        thread.start(); // 启动线程
    }
}
```
2. 实现`Runnable`接口。
```Java
class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("Thread is running");
    }
}

public class Main {
    public static void main(String[] args) {
        Thread thread = new Thread(new MyRunnable());
        thread.start(); // 启动线程
    }
}
```
3. 匿名内部类实现。
```Java
public class Main {
    public static void main(String[] args) {
        Thread thread = new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("Thread is running");
            }
        });
        thread.start(); // 启动线程
    }
}
```

### 说说线程的生命周期和状态

**Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态**：

1. NEW：初始状态，线程被创建了，但没有使用`start()`。
2. RUNNABLE：运行状态，线程被`start()`，等待运行的状态。
3. BLOCKED：阻塞状态，等待锁的释放。
4. WAITING：等待状态，线程等待其他线程做任务。
5. TIME_WAITING：超时等待状态，在指定时间后自行返回。
6. TERMINATED：终止状态，线程运行完毕。

**拓展知识**：
- [可以直接调用 Thread 类的 run 方法吗？](https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html#%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8-thread-%E7%B1%BB%E7%9A%84-run-%E6%96%B9%E6%B3%95%E5%90%97)：调用 `start()` 方法方可启动线程并使线程进入就绪状态，直接执行 `run()` 方法的话不会以多线程的方式执行。

### 谈谈你对线程安全和不安全的理解

- 线程安全和不安全：指在多线程环境下，对同一份数据的访问是否能够保证其正确性和一致性（安全则保证了正确性和一致性，不安全则可能导致数据混乱、丢失、错误）。

### 什么是死锁？

**描述**：

- 指两个或多个线程在执行过程中因争夺资源而相互等待，导致所有线程都无法继续执行的情况。
- 简单来说，各个线程都在等待其他线程释放资源，而它们又不释放资源，最终陷入无限的等待。

**四个必要条件**：

1. 互斥条件：某资源任意时刻只有一个线程占有。
2. 请求与保持条件：一个线程持有某资源，同时请求新资源被阻塞，且对现有资源不释放。
3. 不剥夺条件：线程持有资源未释放时，其他线程不能强行剥夺（独占）。
4. 循环等待条件：多个线程之间形成一条头尾相连的循环等待关系（A->B->C->A）。

### 如何检测死锁？

1. 使用 JDK 自带工具：`jmp`、`jstack`等命令查看虚拟机线程和堆内存使用情况。一般出现线程的或会有`deadlock`的关键字样。
2. 使用`top`、`df`、`free`等命令查看CPU或内存使用情况，死锁时，通常会占用比较高。
3. 使用`jconsole`可视化工具来检测死锁。

### 如何预防和避免死锁？

**如何预防**：

1. 破坏请求与保持条件：一次性申请所有的资源。
2. 破会不剥夺条件：占用部分资源的线程再申请其他资源时，申请不到，就主动释放当前资源。
3. 破坏等待条件：确保所有线程按照相同的顺序请求资源。

**如何避免**：

1. 获取锁时设置一个合适的持有时间。
2. 在分配资源时，借助算法（银行家算法）来对资源进行分配进行计算评估，使其进入安全状态。

### 谈谈你对volatile的理解

**描述**：

1. 轻量级的同步机制。
2. 用于确保可见性和有序性。
3. 用于修饰变量。

**主要作用**：

1. 可见性：每次对该变量的读写操作都会直接从主内存中进行。
2. 有序性：JVM 具有指令重排的特性，使用`volatile`可以让代码按顺序的进行与预期一致。

**缺点**：

- 不保证复合操作原子性：例如，使用`volatile`修饰的自增操作（`i++`）并不是原子操作，因为它涉及读取、增加、写回等多个步骤，这种操作即使使用 `volatile` 也无法确保线程安全。

### 乐观锁和悲观锁

### 谈谈你对synchronized的理解

**描述**：

1. synchronized 加锁的本质都是对对象监视器 monitor 的获取。
2. 在 Java 6 之后， `synchronized` 进行了优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。

**主要作用**：

- 在多线程之间访问资源的同步性，保证被它修饰的代码块或方法在某一时刻只有一个线程可以访问。
- 可以通过`wait()`和`notify()`/`notifyAll()`方法来实现等待/通知机制。

**使用**：

1. 修饰实例方法：进入同步代码时，需要获取当前对象实例的锁。
```Java
synchronized void method() {
    //业务代码
}
```
2. 修饰静态方法：对当前类加锁，作用于类的所有对象实例，进入同步代码块时，要获得当前类（class）的锁。
```Java
synchronized static void method() {
    //业务代码
}
```
3. 修饰代码块：使用`object`，进入前需要获取给定对象的锁。使用`类.class`，进入前需要获取给定的 Class 的锁。
```Java
synchronized(this) {
    //业务代码
}
```

**综上**：

- synchronized 加到 `static`方法和`synchronized(class)`代码块上都是给 Class 类加锁。
- synchronized 加到实例方法上都是给对象实例上锁。

### ReentrantLock是什么

1. ReentrantLock 实现了 Lock 接口。
2. 可重入且可独占式的锁。
3. 提供了轮询、超时、中断、公平锁盒非公平锁等高级功能。
4. 默认使用非公平锁，也可以通过构造器来显式的指定公平锁。
5. 需要显式的调用`lock()`和`unlock()`来加锁和释放锁。

### synchronized和ReentrantLock的区别

1. 都是可重入锁：线程可以再次获取自己的内部锁。比如一个线程获取了某个对象锁，此时这个对象锁还没释放，当其再次想获取这个锁的时候还是可以获取的，如果不可重入的话，就会变成死锁了。
2. synchronized 依赖 JVM 而 ReentrantLock 依赖API：ReentrantLock 需要 `lock()`和`unlock()`方法配合`try/finally`语句来完成。
3. ReentrantLock 提供了更多功能：如等待可中断（`lock.lockInterruptibly`）、可实现公平锁、锁可以绑定多个条件（借助于`Condition`接口与`newCondition()`方法）。

### 什么是AQS

**描述**：

1. Java 并发包中的一个核心的同步框架，它定义了一套多线程访问共享资源的同步机制。
2. 通过 `volatile`关键字来维护变量`int state`来表示同步状态。
3. 通过 FIFO 队列来管理获取同步失败的线程。
4. 当获取同步状态失败后，会被放入到等待队列中阻塞，直到同步状态释放后，队列中线程就会从等待队列中唤醒，并重新尝试获取同步状态。